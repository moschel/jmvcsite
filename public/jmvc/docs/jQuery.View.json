C({"name": "jQuery.View", "type": "class", "parent": "../jquery/view/view.js", "comment": "<p>View provides a uniform interface for using templates with \njQuery. When template engines [jQuery.View.register register] \nthemselves, you are able to:</p>\n\n<ul>\n <li>Use views with jQuery extensions [jQuery.fn.after after], [jQuery.fn.append append],\n  [jQuery.fn.before before], [jQuery.fn.html html], [jQuery.fn.prepend prepend],\n     [jQuery.fn.replace replace], [jQuery.fn.replaceWith replaceWith], [jQuery.fn.text text] like:\n\n<pre><code class='javascript'>$('.foo').html(\"//path/to/view.ejs\",{})</code></pre> </li>\n <li>Compress processed views with [steal.static.views].</li>\n <li>Use the [jQuery.Controller.prototype.view controller/view] plugin to auto-magically\n lookup views.</li>\n <li>Hookup jquery plugins directly in the template.</li>\n\n</ul>\n\n<h2>Supported Template Engines</h2>\n\n<p>JavaScriptMVC comes with the following template languages:</p>\n\n<ul>\n<li>[jQuery.EJS EJS] - provides an ERB like syntax: <code>&lt;%= %&gt;</code></li>\n<li>[Jaml] - A functional approach to JS templates.</li>\n<li>[Micro] - A very lightweight template similar to EJS.</li>\n<li>[jQuery.tmpl] - A very lightweight template similar to EJS.</li>\n</ul>\n\n<p>There are 3rd party plugins that provide other template\nlanguages.</p>\n\n<h2>Use</h2>\n\n<p>Views provide client side templating.  When you use a view, you're\nalmost always wanting to insert the rendered content into the page.</p>\n\n<p>For this reason, the most common way to use a views is through\njQuery modifier functions like [jQuery.fn.html html].  The view\nplugin overwrites these functions so you can render a view and\ninsert its contents into the page with one convenient step.</p>\n\n<p>The following renders the EJS template at \n<code>//app/view/template.ejs</code> with the second parameter used as data.\nIt inserts the result of the template into the \n<code>'#foo'</code> element.</p>\n\n<pre><code class='javascript'>$('#foo').html('//app/view/template.ejs',\n               {message: \"hello world\"})</code></pre>\n\n<p><code>//app/view/template.ejs</code> might look like:</p>\n\n<pre><code class='xml'>&lt;h2>&lt;%= message %>&lt;/h2>&lt;/div></code></pre>\n\n<p>The resulting output would be:</p>\n\n<pre><code class='xml'>&lt;div id='foo'>&lt;h2>hello world&lt;/h2>&lt;/div></code></pre>\n\n<p>The specifics of each templating languages are covered in their\nindividual documentation pages.</p>\n\n<h3>Template Locations</h3>\n\n<p>In the example above, we used \n<code>//app/view/template.ejs</code> as the location of\nour template file. Using // at the start of a path\nreferences the template from the root JavaScriptMVC directory.</p>\n\n<p>If there is no // at the start of the path, the view is looked up\nrelative to the current page.</p>\n\n<p>It's recommended that you use paths rooted from the JavaScriptMVC\ndirectory.  This will make your code less likely to change.</p>\n\n<p>You can also use the [jQuery.Controller.prototype.view controller/view]\nplugin to make looking up templates a little easier.</p>\n\n<h3>Using $.View</h3>\n\n<p>Sometimes you want to get the string result of a view and not\ninsert it into the page right away.  Nested templates are a good\nexample of this.  For this, you can use $.View.  The following\niterates through a list of contacts, and inserts the result of a\nsub template in each:</p>\n\n<pre><code class='xml'>&lt;% for(var i =0 ; i < contacts.length; i++) { %>\n  &lt;%= $.View(\"//contacts/contact.ejs\",contacts[i]) %>\n&lt;% } %></code></pre>\n\n<h2>Compress Views with Steal</h2>\n\n<p>Steal can package processed views in the production \nfile. Because 'stolen' views are already\nprocessed, they don't rely on eval and are much faster. Here's \nhow to steal them:</p>\n\n<pre><code class='javascript'>steal.views('//views/tasks/show.ejs');</code></pre>\n\n<p>Read more about [steal.static.views steal.views].</p>\n\n<h2>$.View</h2>\n\n<p>Looks up a template, processes it, caches it, then renders the template\nwith data and optional helpers.</p>\n\n<p>With [stealjs StealJS], views are typically bundled in the production build.\nThis makes it ok to use views synchronously like:</p>\n\n<pre><code class='javascript'>$.View(\"//myplugin/views/init.ejs\",{message: \"Hello World\"})</code></pre>\n\n<p>If you aren't using StealJS, it's best to use views asynchronously like:</p>\n\n<pre><code class='javascript'>$.View(\"//myplugin/views/init.ejs\",{message: \"Hello World\"}, function(result){\n  // do something with result\n})</code></pre>", "tags": ["core"], "plugin": "jquery/view", "test": "jquery/view/qunit.html", "params": {"view": {"order": 0, "description": "<p>The url or id of an element to use as the template's source.</p>", "name": "view", "type": "String", "optional": false}, "data": {"order": 1, "description": "<p>The data to be passed to the view.</p>", "name": "data", "type": "Object", "optional": false}, "helpers": {"order": 2, "description": "<p>Optional helper functions the view might use. Not all\ntemplates support helpers.</p>", "name": "helpers", "type": "Object", "optional": true}, "callback": {"order": 3, "description": "<p>Optional callback function.  If present, the template is \nretrieved asynchronously.  This is a good idea if you aren't compressing the templates\ninto your view.</p>", "name": "callback", "type": "Object", "optional": true}}, "ret": {"description": "<p>The rendered result of the view.</p>", "type": "String"}, "children": ["jQuery.View.hookups", "jQuery.View.hookup", "jQuery.View.cached", "jQuery.View.cache", "jQuery.View.register", "jQuery.View.ext", "jQuery.View.registerScript", "jQuery.View.preload", "jQuery.fn.prepend", "jQuery.fn.append", "jQuery.fn.after", "jQuery.fn.before", "jQuery.fn.replace", "jQuery.fn.text", "jQuery.fn.html", "jQuery.fn.replaceWith", "jQuery.EJS", "Jaml", "Micro", "jQuery.tmpl"]})